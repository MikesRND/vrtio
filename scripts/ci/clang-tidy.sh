#!/bin/bash
# Run clang-tidy static analysis on all C++ files
# Requires a compile_commands.json file (generated by CMake)

set -euo pipefail

# Color output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Static Analysis (clang-tidy)"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo ""

# Build directory (can be overridden)
BUILD_DIR="${1:-build}"

# Detect number of cores
if command -v nproc &>/dev/null; then
    NPROC=$(nproc)
elif command -v sysctl &>/dev/null; then
    NPROC=$(sysctl -n hw.ncpu)
else
    NPROC=4
fi

# Find clang-tidy (try version-specific names first)
CLANG_TIDY=""
for cmd in clang-tidy-18 clang-tidy-17 clang-tidy-16 clang-tidy-15 clang-tidy; do
    if command -v "$cmd" &>/dev/null; then
        CLANG_TIDY="$cmd"
        break
    fi
done

if [ -z "$CLANG_TIDY" ]; then
    echo -e "${RED}Error: clang-tidy not found${NC}"
    echo "Please install clang-tidy (version 15 or newer recommended)"
    exit 1
fi

VERSION=$($CLANG_TIDY --version | head -1)
echo "Using: $CLANG_TIDY"
echo "Version: $VERSION"
echo "Build directory: $BUILD_DIR"
echo "Parallel jobs: $NPROC"
echo ""

# Check if build directory exists
if [ ! -d "$BUILD_DIR" ]; then
    echo -e "${YELLOW}Build directory not found, creating with compile_commands.json...${NC}"
    mkdir -p "$BUILD_DIR"
fi

# Generate compile_commands.json if it doesn't exist
if [ ! -f "$BUILD_DIR/compile_commands.json" ]; then
    echo "Generating compile_commands.json..."
    cmake -B "$BUILD_DIR" \
        -DCMAKE_EXPORT_COMPILE_COMMANDS=ON \
        -DCMAKE_CXX_STANDARD=20 \
        -DVRTIGO_BUILD_TESTS=ON \
        -DVRTIGO_BUILD_EXAMPLES=ON \
        -DVRTIGO_FETCH_DEPENDENCIES=ON
    echo ""
fi

# Find all C++ source files in tests and examples
# Note: Header-only library, so we analyze tests and examples
FILES=$(find tests examples -type f \( -name "*.cpp" -o -name "*.cc" \) 2>/dev/null || true)

if [ -z "$FILES" ]; then
    echo -e "${YELLOW}Warning: No C++ source files found to analyze${NC}"
    exit 0
fi

FILE_COUNT=$(echo "$FILES" | wc -l)
echo "Analyzing $FILE_COUNT source files..."
echo ""

# Run clang-tidy
ERROR_COUNT=0
WARNING_COUNT=0

# Use run-clang-tidy if available (parallel processing)
if command -v run-clang-tidy &>/dev/null || command -v run-clang-tidy-16 &>/dev/null; then
    RUN_CLANG_TIDY=""
    for cmd in run-clang-tidy-18 run-clang-tidy-17 run-clang-tidy-16 run-clang-tidy-15 run-clang-tidy; do
        if command -v "$cmd" &>/dev/null; then
            RUN_CLANG_TIDY="$cmd"
            break
        fi
    done

    echo "Running parallel analysis..."
    # Run and capture output
    if ! OUTPUT=$($RUN_CLANG_TIDY -p "$BUILD_DIR" -j "$NPROC" "^(tests|examples)/.*\.(cpp|cc)$" 2>&1); then
        ERROR_COUNT=$(echo "$OUTPUT" | grep -c "error:" || true)
        WARNING_COUNT=$(echo "$OUTPUT" | grep -c "warning:" || true)
        echo "$OUTPUT"
    else
        ERROR_COUNT=$(echo "$OUTPUT" | grep -c "error:" || true)
        WARNING_COUNT=$(echo "$OUTPUT" | grep -c "warning:" || true)
        echo "$OUTPUT"
    fi
else
    # Sequential fallback
    echo "Running sequential analysis..."
    while IFS= read -r file; do
        echo -e "${BLUE}Analyzing:${NC} $file"
        if ! OUTPUT=$($CLANG_TIDY -p "$BUILD_DIR" "$file" 2>&1); then
            FILE_ERRORS=$(echo "$OUTPUT" | grep -c "error:" || true)
            FILE_WARNINGS=$(echo "$OUTPUT" | grep -c "warning:" || true)
            ERROR_COUNT=$((ERROR_COUNT + FILE_ERRORS))
            WARNING_COUNT=$((WARNING_COUNT + FILE_WARNINGS))
            echo "$OUTPUT"
        else
            FILE_ERRORS=$(echo "$OUTPUT" | grep -c "error:" || true)
            FILE_WARNINGS=$(echo "$OUTPUT" | grep -c "warning:" || true)
            ERROR_COUNT=$((ERROR_COUNT + FILE_ERRORS))
            WARNING_COUNT=$((WARNING_COUNT + FILE_WARNINGS))
            if [ $FILE_ERRORS -gt 0 ] || [ $FILE_WARNINGS -gt 0 ]; then
                echo "$OUTPUT"
            fi
        fi
    done <<< "$FILES"
fi

echo ""
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
echo "Analysis Summary"
echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"

if [ $ERROR_COUNT -eq 0 ] && [ $WARNING_COUNT -eq 0 ]; then
    echo -e "${GREEN}✓ No issues found!${NC}"
    exit 0
else
    if [ $ERROR_COUNT -gt 0 ]; then
        echo -e "${RED}Errors: $ERROR_COUNT${NC}"
    fi
    if [ $WARNING_COUNT -gt 0 ]; then
        echo -e "${YELLOW}Warnings: $WARNING_COUNT${NC}"
    fi

    if [ $ERROR_COUNT -gt 0 ]; then
        echo ""
        echo -e "${RED}✗ Analysis failed with errors${NC}"
        exit 1
    else
        echo ""
        echo -e "${YELLOW}⚠ Analysis completed with warnings${NC}"
        exit 0
    fi
fi
